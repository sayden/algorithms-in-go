// DO NOT EDIT THIS FILE MANUALLY
// Generated by go generate
package sorting

func ShellUint(u []uint, j int) (newL []uint) {
	if j == 0 {
		j = 4
	}

	newL = make([]uint, len(u))
	copy(newL, u)

	//Interval of 4
	interval := j << 1

	for interval>>1 > 0 {
		interval = interval >> 1

		for i := 0; i < len(newL)-interval; i++ {
			left := newL[i]
			right := newL[i+interval]

			if right < left {
				newL[i] = right
				newL[i+interval] = left
			}
		}
	}

	return
}

func ShellUint8(u []uint8, j int) (newL []uint8) {
	if j == 0 {
		j = 4
	}

	newL = make([]uint8, len(u))
	copy(newL, u)

	//Interval of 4
	interval := j << 1

	for interval>>1 > 0 {
		interval = interval >> 1

		for i := 0; i < len(newL)-interval; i++ {
			left := newL[i]
			right := newL[i+interval]

			if right < left {
				newL[i] = right
				newL[i+interval] = left
			}
		}
	}

	return
}

func ShellUint16(u []uint16, j int) (newL []uint16) {
	if j == 0 {
		j = 4
	}

	newL = make([]uint16, len(u))
	copy(newL, u)

	//Interval of 4
	interval := j << 1

	for interval>>1 > 0 {
		interval = interval >> 1

		for i := 0; i < len(newL)-interval; i++ {
			left := newL[i]
			right := newL[i+interval]

			if right < left {
				newL[i] = right
				newL[i+interval] = left
			}
		}
	}

	return
}

func ShellUint32(u []uint32, j int) (newL []uint32) {
	if j == 0 {
		j = 4
	}

	newL = make([]uint32, len(u))
	copy(newL, u)

	//Interval of 4
	interval := j << 1

	for interval>>1 > 0 {
		interval = interval >> 1

		for i := 0; i < len(newL)-interval; i++ {
			left := newL[i]
			right := newL[i+interval]

			if right < left {
				newL[i] = right
				newL[i+interval] = left
			}
		}
	}

	return
}

func ShellUint64(u []uint64, j int) (newL []uint64) {
	if j == 0 {
		j = 4
	}

	newL = make([]uint64, len(u))
	copy(newL, u)

	//Interval of 4
	interval := j << 1

	for interval>>1 > 0 {
		interval = interval >> 1

		for i := 0; i < len(newL)-interval; i++ {
			left := newL[i]
			right := newL[i+interval]

			if right < left {
				newL[i] = right
				newL[i+interval] = left
			}
		}
	}

	return
}

func ShellInt(u []int, j int) (newL []int) {
	if j == 0 {
		j = 4
	}

	newL = make([]int, len(u))
	copy(newL, u)

	//Interval of 4
	interval := j << 1

	for interval>>1 > 0 {
		interval = interval >> 1

		for i := 0; i < len(newL)-interval; i++ {
			left := newL[i]
			right := newL[i+interval]

			if right < left {
				newL[i] = right
				newL[i+interval] = left
			}
		}
	}

	return
}

func ShellInt8(u []int8, j int) (newL []int8) {
	if j == 0 {
		j = 4
	}

	newL = make([]int8, len(u))
	copy(newL, u)

	//Interval of 4
	interval := j << 1

	for interval>>1 > 0 {
		interval = interval >> 1

		for i := 0; i < len(newL)-interval; i++ {
			left := newL[i]
			right := newL[i+interval]

			if right < left {
				newL[i] = right
				newL[i+interval] = left
			}
		}
	}

	return
}

func ShellInt16(u []int16, j int) (newL []int16) {
	if j == 0 {
		j = 4
	}

	newL = make([]int16, len(u))
	copy(newL, u)

	//Interval of 4
	interval := j << 1

	for interval>>1 > 0 {
		interval = interval >> 1

		for i := 0; i < len(newL)-interval; i++ {
			left := newL[i]
			right := newL[i+interval]

			if right < left {
				newL[i] = right
				newL[i+interval] = left
			}
		}
	}

	return
}

func ShellInt32(u []int32, j int) (newL []int32) {
	if j == 0 {
		j = 4
	}

	newL = make([]int32, len(u))
	copy(newL, u)

	//Interval of 4
	interval := j << 1

	for interval>>1 > 0 {
		interval = interval >> 1

		for i := 0; i < len(newL)-interval; i++ {
			left := newL[i]
			right := newL[i+interval]

			if right < left {
				newL[i] = right
				newL[i+interval] = left
			}
		}
	}

	return
}

func ShellInt64(u []int64, j int) (newL []int64) {
	if j == 0 {
		j = 4
	}

	newL = make([]int64, len(u))
	copy(newL, u)

	//Interval of 4
	interval := j << 1

	for interval>>1 > 0 {
		interval = interval >> 1

		for i := 0; i < len(newL)-interval; i++ {
			left := newL[i]
			right := newL[i+interval]

			if right < left {
				newL[i] = right
				newL[i+interval] = left
			}
		}
	}

	return
}

func ShellFloat32(u []float32, j int) (newL []float32) {
	if j == 0 {
		j = 4
	}

	newL = make([]float32, len(u))
	copy(newL, u)

	//Interval of 4
	interval := j << 1

	for interval>>1 > 0 {
		interval = interval >> 1

		for i := 0; i < len(newL)-interval; i++ {
			left := newL[i]
			right := newL[i+interval]

			if right < left {
				newL[i] = right
				newL[i+interval] = left
			}
		}
	}

	return
}

func ShellFloat64(u []float64, j int) (newL []float64) {
	if j == 0 {
		j = 4
	}

	newL = make([]float64, len(u))
	copy(newL, u)

	//Interval of 4
	interval := j << 1

	for interval>>1 > 0 {
		interval = interval >> 1

		for i := 0; i < len(newL)-interval; i++ {
			left := newL[i]
			right := newL[i+interval]

			if right < left {
				newL[i] = right
				newL[i+interval] = left
			}
		}
	}

	return
}

func ShellByte(u []byte, j int) (newL []byte) {
	if j == 0 {
		j = 4
	}

	newL = make([]byte, len(u))
	copy(newL, u)

	//Interval of 4
	interval := j << 1

	for interval>>1 > 0 {
		interval = interval >> 1

		for i := 0; i < len(newL)-interval; i++ {
			left := newL[i]
			right := newL[i+interval]

			if right < left {
				newL[i] = right
				newL[i+interval] = left
			}
		}
	}

	return
}

func ShellRune(u []rune, j int) (newL []rune) {
	if j == 0 {
		j = 4
	}

	newL = make([]rune, len(u))
	copy(newL, u)

	//Interval of 4
	interval := j << 1

	for interval>>1 > 0 {
		interval = interval >> 1

		for i := 0; i < len(newL)-interval; i++ {
			left := newL[i]
			right := newL[i+interval]

			if right < left {
				newL[i] = right
				newL[i+interval] = left
			}
		}
	}

	return
}

func ShellUintptr(u []uintptr, j int) (newL []uintptr) {
	if j == 0 {
		j = 4
	}

	newL = make([]uintptr, len(u))
	copy(newL, u)

	//Interval of 4
	interval := j << 1

	for interval>>1 > 0 {
		interval = interval >> 1

		for i := 0; i < len(newL)-interval; i++ {
			left := newL[i]
			right := newL[i+interval]

			if right < left {
				newL[i] = right
				newL[i+interval] = left
			}
		}
	}

	return
}
