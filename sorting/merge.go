// DO NOT EDIT THIS FILE MANUALLY
// Generated by go generate
package sorting

func MergeUint(u []uint) (newL []uint) {

	if len(u) <= 1 {
		return u
	}

	middlePoint := len(u) / 2

	leftHalf := u[:middlePoint]
	rightHalf := u[middlePoint:]

	left := MergeUint(leftHalf)
	right := MergeUint(rightHalf)

	merge := func(left, right []uint) []uint {
		var result []uint
		for len(left) > 0 || len(right) > 0 {
			if len(left) > 0 && len(right) > 0 {
				if left[0] <= right[0] {
					result = append(result, left[0])
					left = left[1:]
				} else {
					result = append(result, right[0])
					right = right[1:]
				}
			} else if len(left) > 0 {
				result = append(result, left[0])
				left = left[1:]
			} else if len(right) > 0 {
				result = append(result, right[0])
				right = right[1:]
			}
		}

		return result
	}

	return merge(left, right)
}

func MergeUint8(u []uint8) (newL []uint8) {

	if len(u) <= 1 {
		return u
	}

	middlePoint := len(u) / 2

	leftHalf := u[:middlePoint]
	rightHalf := u[middlePoint:]

	left := MergeUint8(leftHalf)
	right := MergeUint8(rightHalf)

	merge := func(left, right []uint8) []uint8 {
		var result []uint8
		for len(left) > 0 || len(right) > 0 {
			if len(left) > 0 && len(right) > 0 {
				if left[0] <= right[0] {
					result = append(result, left[0])
					left = left[1:]
				} else {
					result = append(result, right[0])
					right = right[1:]
				}
			} else if len(left) > 0 {
				result = append(result, left[0])
				left = left[1:]
			} else if len(right) > 0 {
				result = append(result, right[0])
				right = right[1:]
			}
		}

		return result
	}

	return merge(left, right)
}

func MergeUint16(u []uint16) (newL []uint16) {

	if len(u) <= 1 {
		return u
	}

	middlePoint := len(u) / 2

	leftHalf := u[:middlePoint]
	rightHalf := u[middlePoint:]

	left := MergeUint16(leftHalf)
	right := MergeUint16(rightHalf)

	merge := func(left, right []uint16) []uint16 {
		var result []uint16
		for len(left) > 0 || len(right) > 0 {
			if len(left) > 0 && len(right) > 0 {
				if left[0] <= right[0] {
					result = append(result, left[0])
					left = left[1:]
				} else {
					result = append(result, right[0])
					right = right[1:]
				}
			} else if len(left) > 0 {
				result = append(result, left[0])
				left = left[1:]
			} else if len(right) > 0 {
				result = append(result, right[0])
				right = right[1:]
			}
		}

		return result
	}

	return merge(left, right)
}

func MergeUint32(u []uint32) (newL []uint32) {

	if len(u) <= 1 {
		return u
	}

	middlePoint := len(u) / 2

	leftHalf := u[:middlePoint]
	rightHalf := u[middlePoint:]

	left := MergeUint32(leftHalf)
	right := MergeUint32(rightHalf)

	merge := func(left, right []uint32) []uint32 {
		var result []uint32
		for len(left) > 0 || len(right) > 0 {
			if len(left) > 0 && len(right) > 0 {
				if left[0] <= right[0] {
					result = append(result, left[0])
					left = left[1:]
				} else {
					result = append(result, right[0])
					right = right[1:]
				}
			} else if len(left) > 0 {
				result = append(result, left[0])
				left = left[1:]
			} else if len(right) > 0 {
				result = append(result, right[0])
				right = right[1:]
			}
		}

		return result
	}

	return merge(left, right)
}

func MergeUint64(u []uint64) (newL []uint64) {

	if len(u) <= 1 {
		return u
	}

	middlePoint := len(u) / 2

	leftHalf := u[:middlePoint]
	rightHalf := u[middlePoint:]

	left := MergeUint64(leftHalf)
	right := MergeUint64(rightHalf)

	merge := func(left, right []uint64) []uint64 {
		var result []uint64
		for len(left) > 0 || len(right) > 0 {
			if len(left) > 0 && len(right) > 0 {
				if left[0] <= right[0] {
					result = append(result, left[0])
					left = left[1:]
				} else {
					result = append(result, right[0])
					right = right[1:]
				}
			} else if len(left) > 0 {
				result = append(result, left[0])
				left = left[1:]
			} else if len(right) > 0 {
				result = append(result, right[0])
				right = right[1:]
			}
		}

		return result
	}

	return merge(left, right)
}

func MergeInt(u []int) (newL []int) {

	if len(u) <= 1 {
		return u
	}

	middlePoint := len(u) / 2

	leftHalf := u[:middlePoint]
	rightHalf := u[middlePoint:]

	left := MergeInt(leftHalf)
	right := MergeInt(rightHalf)

	merge := func(left, right []int) []int {
		var result []int
		for len(left) > 0 || len(right) > 0 {
			if len(left) > 0 && len(right) > 0 {
				if left[0] <= right[0] {
					result = append(result, left[0])
					left = left[1:]
				} else {
					result = append(result, right[0])
					right = right[1:]
				}
			} else if len(left) > 0 {
				result = append(result, left[0])
				left = left[1:]
			} else if len(right) > 0 {
				result = append(result, right[0])
				right = right[1:]
			}
		}

		return result
	}

	return merge(left, right)
}

func MergeInt8(u []int8) (newL []int8) {

	if len(u) <= 1 {
		return u
	}

	middlePoint := len(u) / 2

	leftHalf := u[:middlePoint]
	rightHalf := u[middlePoint:]

	left := MergeInt8(leftHalf)
	right := MergeInt8(rightHalf)

	merge := func(left, right []int8) []int8 {
		var result []int8
		for len(left) > 0 || len(right) > 0 {
			if len(left) > 0 && len(right) > 0 {
				if left[0] <= right[0] {
					result = append(result, left[0])
					left = left[1:]
				} else {
					result = append(result, right[0])
					right = right[1:]
				}
			} else if len(left) > 0 {
				result = append(result, left[0])
				left = left[1:]
			} else if len(right) > 0 {
				result = append(result, right[0])
				right = right[1:]
			}
		}

		return result
	}

	return merge(left, right)
}

func MergeInt16(u []int16) (newL []int16) {

	if len(u) <= 1 {
		return u
	}

	middlePoint := len(u) / 2

	leftHalf := u[:middlePoint]
	rightHalf := u[middlePoint:]

	left := MergeInt16(leftHalf)
	right := MergeInt16(rightHalf)

	merge := func(left, right []int16) []int16 {
		var result []int16
		for len(left) > 0 || len(right) > 0 {
			if len(left) > 0 && len(right) > 0 {
				if left[0] <= right[0] {
					result = append(result, left[0])
					left = left[1:]
				} else {
					result = append(result, right[0])
					right = right[1:]
				}
			} else if len(left) > 0 {
				result = append(result, left[0])
				left = left[1:]
			} else if len(right) > 0 {
				result = append(result, right[0])
				right = right[1:]
			}
		}

		return result
	}

	return merge(left, right)
}

func MergeInt32(u []int32) (newL []int32) {

	if len(u) <= 1 {
		return u
	}

	middlePoint := len(u) / 2

	leftHalf := u[:middlePoint]
	rightHalf := u[middlePoint:]

	left := MergeInt32(leftHalf)
	right := MergeInt32(rightHalf)

	merge := func(left, right []int32) []int32 {
		var result []int32
		for len(left) > 0 || len(right) > 0 {
			if len(left) > 0 && len(right) > 0 {
				if left[0] <= right[0] {
					result = append(result, left[0])
					left = left[1:]
				} else {
					result = append(result, right[0])
					right = right[1:]
				}
			} else if len(left) > 0 {
				result = append(result, left[0])
				left = left[1:]
			} else if len(right) > 0 {
				result = append(result, right[0])
				right = right[1:]
			}
		}

		return result
	}

	return merge(left, right)
}

func MergeInt64(u []int64) (newL []int64) {

	if len(u) <= 1 {
		return u
	}

	middlePoint := len(u) / 2

	leftHalf := u[:middlePoint]
	rightHalf := u[middlePoint:]

	left := MergeInt64(leftHalf)
	right := MergeInt64(rightHalf)

	merge := func(left, right []int64) []int64 {
		var result []int64
		for len(left) > 0 || len(right) > 0 {
			if len(left) > 0 && len(right) > 0 {
				if left[0] <= right[0] {
					result = append(result, left[0])
					left = left[1:]
				} else {
					result = append(result, right[0])
					right = right[1:]
				}
			} else if len(left) > 0 {
				result = append(result, left[0])
				left = left[1:]
			} else if len(right) > 0 {
				result = append(result, right[0])
				right = right[1:]
			}
		}

		return result
	}

	return merge(left, right)
}

func MergeFloat32(u []float32) (newL []float32) {

	if len(u) <= 1 {
		return u
	}

	middlePoint := len(u) / 2

	leftHalf := u[:middlePoint]
	rightHalf := u[middlePoint:]

	left := MergeFloat32(leftHalf)
	right := MergeFloat32(rightHalf)

	merge := func(left, right []float32) []float32 {
		var result []float32
		for len(left) > 0 || len(right) > 0 {
			if len(left) > 0 && len(right) > 0 {
				if left[0] <= right[0] {
					result = append(result, left[0])
					left = left[1:]
				} else {
					result = append(result, right[0])
					right = right[1:]
				}
			} else if len(left) > 0 {
				result = append(result, left[0])
				left = left[1:]
			} else if len(right) > 0 {
				result = append(result, right[0])
				right = right[1:]
			}
		}

		return result
	}

	return merge(left, right)
}

func MergeFloat64(u []float64) (newL []float64) {

	if len(u) <= 1 {
		return u
	}

	middlePoint := len(u) / 2

	leftHalf := u[:middlePoint]
	rightHalf := u[middlePoint:]

	left := MergeFloat64(leftHalf)
	right := MergeFloat64(rightHalf)

	merge := func(left, right []float64) []float64 {
		var result []float64
		for len(left) > 0 || len(right) > 0 {
			if len(left) > 0 && len(right) > 0 {
				if left[0] <= right[0] {
					result = append(result, left[0])
					left = left[1:]
				} else {
					result = append(result, right[0])
					right = right[1:]
				}
			} else if len(left) > 0 {
				result = append(result, left[0])
				left = left[1:]
			} else if len(right) > 0 {
				result = append(result, right[0])
				right = right[1:]
			}
		}

		return result
	}

	return merge(left, right)
}

func MergeByte(u []byte) (newL []byte) {

	if len(u) <= 1 {
		return u
	}

	middlePoint := len(u) / 2

	leftHalf := u[:middlePoint]
	rightHalf := u[middlePoint:]

	left := MergeByte(leftHalf)
	right := MergeByte(rightHalf)

	merge := func(left, right []byte) []byte {
		var result []byte
		for len(left) > 0 || len(right) > 0 {
			if len(left) > 0 && len(right) > 0 {
				if left[0] <= right[0] {
					result = append(result, left[0])
					left = left[1:]
				} else {
					result = append(result, right[0])
					right = right[1:]
				}
			} else if len(left) > 0 {
				result = append(result, left[0])
				left = left[1:]
			} else if len(right) > 0 {
				result = append(result, right[0])
				right = right[1:]
			}
		}

		return result
	}

	return merge(left, right)
}

func MergeRune(u []rune) (newL []rune) {

	if len(u) <= 1 {
		return u
	}

	middlePoint := len(u) / 2

	leftHalf := u[:middlePoint]
	rightHalf := u[middlePoint:]

	left := MergeRune(leftHalf)
	right := MergeRune(rightHalf)

	merge := func(left, right []rune) []rune {
		var result []rune
		for len(left) > 0 || len(right) > 0 {
			if len(left) > 0 && len(right) > 0 {
				if left[0] <= right[0] {
					result = append(result, left[0])
					left = left[1:]
				} else {
					result = append(result, right[0])
					right = right[1:]
				}
			} else if len(left) > 0 {
				result = append(result, left[0])
				left = left[1:]
			} else if len(right) > 0 {
				result = append(result, right[0])
				right = right[1:]
			}
		}

		return result
	}

	return merge(left, right)
}

func MergeUintptr(u []uintptr) (newL []uintptr) {

	if len(u) <= 1 {
		return u
	}

	middlePoint := len(u) / 2

	leftHalf := u[:middlePoint]
	rightHalf := u[middlePoint:]

	left := MergeUintptr(leftHalf)
	right := MergeUintptr(rightHalf)

	merge := func(left, right []uintptr) []uintptr {
		var result []uintptr
		for len(left) > 0 || len(right) > 0 {
			if len(left) > 0 && len(right) > 0 {
				if left[0] <= right[0] {
					result = append(result, left[0])
					left = left[1:]
				} else {
					result = append(result, right[0])
					right = right[1:]
				}
			} else if len(left) > 0 {
				result = append(result, left[0])
				left = left[1:]
			} else if len(right) > 0 {
				result = append(result, right[0])
				right = right[1:]
			}
		}

		return result
	}

	return merge(left, right)
}
