// DO NOT EDIT THIS FILE MANUALLY
// Generated by go generate
package sorting

import "github.com/thehivecorporation/algorithms-in-go/common"

func heapifyUint(u []uint, i, max int) {
	left := 2 * i
	right := left + 1
	largest := 0

	if left < max && u[left] > u[i] {
		largest = left
	} else {
		largest = i
	}

	if right < max && u[right] > u[largest] {
		largest = right
	}
	if largest != i {
		common.SwapUint(u, i, largest)

		heapifyUint(u, largest, max)
	}
}

func HeapUint(u []uint) []uint {
	newL := make([]uint, len(u))
	copy(newL, u)

	for i := (len(u) / 2) - 1; i > 0; i-- {
		heapifyUint(newL, i, len(u))
	}

	for i := len(u) - 1; i > 0; i-- {
		common.SwapUint(newL, 0, i)

		heapifyUint(newL, 0, i)
	}

	return newL
}

func heapifyUint8(u []uint8, i, max int) {
	left := 2 * i
	right := left + 1
	largest := 0

	if left < max && u[left] > u[i] {
		largest = left
	} else {
		largest = i
	}

	if right < max && u[right] > u[largest] {
		largest = right
	}
	if largest != i {
		common.SwapUint8(u, i, largest)

		heapifyUint8(u, largest, max)
	}
}

func HeapUint8(u []uint8) []uint8 {
	newL := make([]uint8, len(u))
	copy(newL, u)

	for i := (len(u) / 2) - 1; i > 0; i-- {
		heapifyUint8(newL, i, len(u))
	}

	for i := len(u) - 1; i > 0; i-- {
		common.SwapUint8(newL, 0, i)

		heapifyUint8(newL, 0, i)
	}

	return newL
}

func heapifyUint16(u []uint16, i, max int) {
	left := 2 * i
	right := left + 1
	largest := 0

	if left < max && u[left] > u[i] {
		largest = left
	} else {
		largest = i
	}

	if right < max && u[right] > u[largest] {
		largest = right
	}
	if largest != i {
		common.SwapUint16(u, i, largest)

		heapifyUint16(u, largest, max)
	}
}

func HeapUint16(u []uint16) []uint16 {
	newL := make([]uint16, len(u))
	copy(newL, u)

	for i := (len(u) / 2) - 1; i > 0; i-- {
		heapifyUint16(newL, i, len(u))
	}

	for i := len(u) - 1; i > 0; i-- {
		common.SwapUint16(newL, 0, i)

		heapifyUint16(newL, 0, i)
	}

	return newL
}

func heapifyUint32(u []uint32, i, max int) {
	left := 2 * i
	right := left + 1
	largest := 0

	if left < max && u[left] > u[i] {
		largest = left
	} else {
		largest = i
	}

	if right < max && u[right] > u[largest] {
		largest = right
	}
	if largest != i {
		common.SwapUint32(u, i, largest)

		heapifyUint32(u, largest, max)
	}
}

func HeapUint32(u []uint32) []uint32 {
	newL := make([]uint32, len(u))
	copy(newL, u)

	for i := (len(u) / 2) - 1; i > 0; i-- {
		heapifyUint32(newL, i, len(u))
	}

	for i := len(u) - 1; i > 0; i-- {
		common.SwapUint32(newL, 0, i)

		heapifyUint32(newL, 0, i)
	}

	return newL
}

func heapifyUint64(u []uint64, i, max int) {
	left := 2 * i
	right := left + 1
	largest := 0

	if left < max && u[left] > u[i] {
		largest = left
	} else {
		largest = i
	}

	if right < max && u[right] > u[largest] {
		largest = right
	}
	if largest != i {
		common.SwapUint64(u, i, largest)

		heapifyUint64(u, largest, max)
	}
}

func HeapUint64(u []uint64) []uint64 {
	newL := make([]uint64, len(u))
	copy(newL, u)

	for i := (len(u) / 2) - 1; i > 0; i-- {
		heapifyUint64(newL, i, len(u))
	}

	for i := len(u) - 1; i > 0; i-- {
		common.SwapUint64(newL, 0, i)

		heapifyUint64(newL, 0, i)
	}

	return newL
}

func heapifyInt(u []int, i, max int) {
	left := 2 * i
	right := left + 1
	largest := 0

	if left < max && u[left] > u[i] {
		largest = left
	} else {
		largest = i
	}

	if right < max && u[right] > u[largest] {
		largest = right
	}
	if largest != i {
		common.SwapInt(u, i, largest)

		heapifyInt(u, largest, max)
	}
}

func HeapInt(u []int) []int {
	newL := make([]int, len(u))
	copy(newL, u)

	for i := (len(u) / 2) - 1; i > 0; i-- {
		heapifyInt(newL, i, len(u))
	}

	for i := len(u) - 1; i > 0; i-- {
		common.SwapInt(newL, 0, i)

		heapifyInt(newL, 0, i)
	}

	return newL
}

func heapifyInt8(u []int8, i, max int) {
	left := 2 * i
	right := left + 1
	largest := 0

	if left < max && u[left] > u[i] {
		largest = left
	} else {
		largest = i
	}

	if right < max && u[right] > u[largest] {
		largest = right
	}
	if largest != i {
		common.SwapInt8(u, i, largest)

		heapifyInt8(u, largest, max)
	}
}

func HeapInt8(u []int8) []int8 {
	newL := make([]int8, len(u))
	copy(newL, u)

	for i := (len(u) / 2) - 1; i > 0; i-- {
		heapifyInt8(newL, i, len(u))
	}

	for i := len(u) - 1; i > 0; i-- {
		common.SwapInt8(newL, 0, i)

		heapifyInt8(newL, 0, i)
	}

	return newL
}

func heapifyInt16(u []int16, i, max int) {
	left := 2 * i
	right := left + 1
	largest := 0

	if left < max && u[left] > u[i] {
		largest = left
	} else {
		largest = i
	}

	if right < max && u[right] > u[largest] {
		largest = right
	}
	if largest != i {
		common.SwapInt16(u, i, largest)

		heapifyInt16(u, largest, max)
	}
}

func HeapInt16(u []int16) []int16 {
	newL := make([]int16, len(u))
	copy(newL, u)

	for i := (len(u) / 2) - 1; i > 0; i-- {
		heapifyInt16(newL, i, len(u))
	}

	for i := len(u) - 1; i > 0; i-- {
		common.SwapInt16(newL, 0, i)

		heapifyInt16(newL, 0, i)
	}

	return newL
}

func heapifyInt32(u []int32, i, max int) {
	left := 2 * i
	right := left + 1
	largest := 0

	if left < max && u[left] > u[i] {
		largest = left
	} else {
		largest = i
	}

	if right < max && u[right] > u[largest] {
		largest = right
	}
	if largest != i {
		common.SwapInt32(u, i, largest)

		heapifyInt32(u, largest, max)
	}
}

func HeapInt32(u []int32) []int32 {
	newL := make([]int32, len(u))
	copy(newL, u)

	for i := (len(u) / 2) - 1; i > 0; i-- {
		heapifyInt32(newL, i, len(u))
	}

	for i := len(u) - 1; i > 0; i-- {
		common.SwapInt32(newL, 0, i)

		heapifyInt32(newL, 0, i)
	}

	return newL
}

func heapifyInt64(u []int64, i, max int) {
	left := 2 * i
	right := left + 1
	largest := 0

	if left < max && u[left] > u[i] {
		largest = left
	} else {
		largest = i
	}

	if right < max && u[right] > u[largest] {
		largest = right
	}
	if largest != i {
		common.SwapInt64(u, i, largest)

		heapifyInt64(u, largest, max)
	}
}

func HeapInt64(u []int64) []int64 {
	newL := make([]int64, len(u))
	copy(newL, u)

	for i := (len(u) / 2) - 1; i > 0; i-- {
		heapifyInt64(newL, i, len(u))
	}

	for i := len(u) - 1; i > 0; i-- {
		common.SwapInt64(newL, 0, i)

		heapifyInt64(newL, 0, i)
	}

	return newL
}

func heapifyFloat32(u []float32, i, max int) {
	left := 2 * i
	right := left + 1
	largest := 0

	if left < max && u[left] > u[i] {
		largest = left
	} else {
		largest = i
	}

	if right < max && u[right] > u[largest] {
		largest = right
	}
	if largest != i {
		common.SwapFloat32(u, i, largest)

		heapifyFloat32(u, largest, max)
	}
}

func HeapFloat32(u []float32) []float32 {
	newL := make([]float32, len(u))
	copy(newL, u)

	for i := (len(u) / 2) - 1; i > 0; i-- {
		heapifyFloat32(newL, i, len(u))
	}

	for i := len(u) - 1; i > 0; i-- {
		common.SwapFloat32(newL, 0, i)

		heapifyFloat32(newL, 0, i)
	}

	return newL
}

func heapifyFloat64(u []float64, i, max int) {
	left := 2 * i
	right := left + 1
	largest := 0

	if left < max && u[left] > u[i] {
		largest = left
	} else {
		largest = i
	}

	if right < max && u[right] > u[largest] {
		largest = right
	}
	if largest != i {
		common.SwapFloat64(u, i, largest)

		heapifyFloat64(u, largest, max)
	}
}

func HeapFloat64(u []float64) []float64 {
	newL := make([]float64, len(u))
	copy(newL, u)

	for i := (len(u) / 2) - 1; i > 0; i-- {
		heapifyFloat64(newL, i, len(u))
	}

	for i := len(u) - 1; i > 0; i-- {
		common.SwapFloat64(newL, 0, i)

		heapifyFloat64(newL, 0, i)
	}

	return newL
}

func heapifyByte(u []byte, i, max int) {
	left := 2 * i
	right := left + 1
	largest := 0

	if left < max && u[left] > u[i] {
		largest = left
	} else {
		largest = i
	}

	if right < max && u[right] > u[largest] {
		largest = right
	}
	if largest != i {
		common.SwapByte(u, i, largest)

		heapifyByte(u, largest, max)
	}
}

func HeapByte(u []byte) []byte {
	newL := make([]byte, len(u))
	copy(newL, u)

	for i := (len(u) / 2) - 1; i > 0; i-- {
		heapifyByte(newL, i, len(u))
	}

	for i := len(u) - 1; i > 0; i-- {
		common.SwapByte(newL, 0, i)

		heapifyByte(newL, 0, i)
	}

	return newL
}

func heapifyRune(u []rune, i, max int) {
	left := 2 * i
	right := left + 1
	largest := 0

	if left < max && u[left] > u[i] {
		largest = left
	} else {
		largest = i
	}

	if right < max && u[right] > u[largest] {
		largest = right
	}
	if largest != i {
		common.SwapRune(u, i, largest)

		heapifyRune(u, largest, max)
	}
}

func HeapRune(u []rune) []rune {
	newL := make([]rune, len(u))
	copy(newL, u)

	for i := (len(u) / 2) - 1; i > 0; i-- {
		heapifyRune(newL, i, len(u))
	}

	for i := len(u) - 1; i > 0; i-- {
		common.SwapRune(newL, 0, i)

		heapifyRune(newL, 0, i)
	}

	return newL
}

func heapifyUintptr(u []uintptr, i, max int) {
	left := 2 * i
	right := left + 1
	largest := 0

	if left < max && u[left] > u[i] {
		largest = left
	} else {
		largest = i
	}

	if right < max && u[right] > u[largest] {
		largest = right
	}
	if largest != i {
		common.SwapUintptr(u, i, largest)

		heapifyUintptr(u, largest, max)
	}
}

func HeapUintptr(u []uintptr) []uintptr {
	newL := make([]uintptr, len(u))
	copy(newL, u)

	for i := (len(u) / 2) - 1; i > 0; i-- {
		heapifyUintptr(newL, i, len(u))
	}

	for i := len(u) - 1; i > 0; i-- {
		common.SwapUintptr(newL, 0, i)

		heapifyUintptr(newL, 0, i)
	}

	return newL
}
