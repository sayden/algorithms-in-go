// DO NOT EDIT THIS FILE MANUALLY
// Generated by go generate
package sorting

import "math/rand"

func QuickUint(u []uint) []uint {
	length := len(u)

	if length <= 1 {
		sliceCopy := make([]uint, length)
		copy(sliceCopy, u)
		return sliceCopy
	}

	m := u[rand.Intn(length)]

	less := make([]uint, 0, length)
	middle := make([]uint, 0, length)
	more := make([]uint, 0, length)

	for _, item := range u {
		switch {
		case item < m:
			less = append(less, item)
		case item == m:
			middle = append(middle, item)
		case item > m:
			more = append(more, item)
		}
	}

	less, more = QuickUint(less), QuickUint(more)

	less = append(less, middle...)
	less = append(less, more...)

	return less
}

func QuickUint8(u []uint8) []uint8 {
	length := len(u)

	if length <= 1 {
		sliceCopy := make([]uint8, length)
		copy(sliceCopy, u)
		return sliceCopy
	}

	m := u[rand.Intn(length)]

	less := make([]uint8, 0, length)
	middle := make([]uint8, 0, length)
	more := make([]uint8, 0, length)

	for _, item := range u {
		switch {
		case item < m:
			less = append(less, item)
		case item == m:
			middle = append(middle, item)
		case item > m:
			more = append(more, item)
		}
	}

	less, more = QuickUint8(less), QuickUint8(more)

	less = append(less, middle...)
	less = append(less, more...)

	return less
}

func QuickUint16(u []uint16) []uint16 {
	length := len(u)

	if length <= 1 {
		sliceCopy := make([]uint16, length)
		copy(sliceCopy, u)
		return sliceCopy
	}

	m := u[rand.Intn(length)]

	less := make([]uint16, 0, length)
	middle := make([]uint16, 0, length)
	more := make([]uint16, 0, length)

	for _, item := range u {
		switch {
		case item < m:
			less = append(less, item)
		case item == m:
			middle = append(middle, item)
		case item > m:
			more = append(more, item)
		}
	}

	less, more = QuickUint16(less), QuickUint16(more)

	less = append(less, middle...)
	less = append(less, more...)

	return less
}

func QuickUint32(u []uint32) []uint32 {
	length := len(u)

	if length <= 1 {
		sliceCopy := make([]uint32, length)
		copy(sliceCopy, u)
		return sliceCopy
	}

	m := u[rand.Intn(length)]

	less := make([]uint32, 0, length)
	middle := make([]uint32, 0, length)
	more := make([]uint32, 0, length)

	for _, item := range u {
		switch {
		case item < m:
			less = append(less, item)
		case item == m:
			middle = append(middle, item)
		case item > m:
			more = append(more, item)
		}
	}

	less, more = QuickUint32(less), QuickUint32(more)

	less = append(less, middle...)
	less = append(less, more...)

	return less
}

func QuickUint64(u []uint64) []uint64 {
	length := len(u)

	if length <= 1 {
		sliceCopy := make([]uint64, length)
		copy(sliceCopy, u)
		return sliceCopy
	}

	m := u[rand.Intn(length)]

	less := make([]uint64, 0, length)
	middle := make([]uint64, 0, length)
	more := make([]uint64, 0, length)

	for _, item := range u {
		switch {
		case item < m:
			less = append(less, item)
		case item == m:
			middle = append(middle, item)
		case item > m:
			more = append(more, item)
		}
	}

	less, more = QuickUint64(less), QuickUint64(more)

	less = append(less, middle...)
	less = append(less, more...)

	return less
}

func QuickInt(u []int) []int {
	length := len(u)

	if length <= 1 {
		sliceCopy := make([]int, length)
		copy(sliceCopy, u)
		return sliceCopy
	}

	m := u[rand.Intn(length)]

	less := make([]int, 0, length)
	middle := make([]int, 0, length)
	more := make([]int, 0, length)

	for _, item := range u {
		switch {
		case item < m:
			less = append(less, item)
		case item == m:
			middle = append(middle, item)
		case item > m:
			more = append(more, item)
		}
	}

	less, more = QuickInt(less), QuickInt(more)

	less = append(less, middle...)
	less = append(less, more...)

	return less
}

func QuickInt8(u []int8) []int8 {
	length := len(u)

	if length <= 1 {
		sliceCopy := make([]int8, length)
		copy(sliceCopy, u)
		return sliceCopy
	}

	m := u[rand.Intn(length)]

	less := make([]int8, 0, length)
	middle := make([]int8, 0, length)
	more := make([]int8, 0, length)

	for _, item := range u {
		switch {
		case item < m:
			less = append(less, item)
		case item == m:
			middle = append(middle, item)
		case item > m:
			more = append(more, item)
		}
	}

	less, more = QuickInt8(less), QuickInt8(more)

	less = append(less, middle...)
	less = append(less, more...)

	return less
}

func QuickInt16(u []int16) []int16 {
	length := len(u)

	if length <= 1 {
		sliceCopy := make([]int16, length)
		copy(sliceCopy, u)
		return sliceCopy
	}

	m := u[rand.Intn(length)]

	less := make([]int16, 0, length)
	middle := make([]int16, 0, length)
	more := make([]int16, 0, length)

	for _, item := range u {
		switch {
		case item < m:
			less = append(less, item)
		case item == m:
			middle = append(middle, item)
		case item > m:
			more = append(more, item)
		}
	}

	less, more = QuickInt16(less), QuickInt16(more)

	less = append(less, middle...)
	less = append(less, more...)

	return less
}

func QuickInt32(u []int32) []int32 {
	length := len(u)

	if length <= 1 {
		sliceCopy := make([]int32, length)
		copy(sliceCopy, u)
		return sliceCopy
	}

	m := u[rand.Intn(length)]

	less := make([]int32, 0, length)
	middle := make([]int32, 0, length)
	more := make([]int32, 0, length)

	for _, item := range u {
		switch {
		case item < m:
			less = append(less, item)
		case item == m:
			middle = append(middle, item)
		case item > m:
			more = append(more, item)
		}
	}

	less, more = QuickInt32(less), QuickInt32(more)

	less = append(less, middle...)
	less = append(less, more...)

	return less
}

func QuickInt64(u []int64) []int64 {
	length := len(u)

	if length <= 1 {
		sliceCopy := make([]int64, length)
		copy(sliceCopy, u)
		return sliceCopy
	}

	m := u[rand.Intn(length)]

	less := make([]int64, 0, length)
	middle := make([]int64, 0, length)
	more := make([]int64, 0, length)

	for _, item := range u {
		switch {
		case item < m:
			less = append(less, item)
		case item == m:
			middle = append(middle, item)
		case item > m:
			more = append(more, item)
		}
	}

	less, more = QuickInt64(less), QuickInt64(more)

	less = append(less, middle...)
	less = append(less, more...)

	return less
}

func QuickFloat32(u []float32) []float32 {
	length := len(u)

	if length <= 1 {
		sliceCopy := make([]float32, length)
		copy(sliceCopy, u)
		return sliceCopy
	}

	m := u[rand.Intn(length)]

	less := make([]float32, 0, length)
	middle := make([]float32, 0, length)
	more := make([]float32, 0, length)

	for _, item := range u {
		switch {
		case item < m:
			less = append(less, item)
		case item == m:
			middle = append(middle, item)
		case item > m:
			more = append(more, item)
		}
	}

	less, more = QuickFloat32(less), QuickFloat32(more)

	less = append(less, middle...)
	less = append(less, more...)

	return less
}

func QuickFloat64(u []float64) []float64 {
	length := len(u)

	if length <= 1 {
		sliceCopy := make([]float64, length)
		copy(sliceCopy, u)
		return sliceCopy
	}

	m := u[rand.Intn(length)]

	less := make([]float64, 0, length)
	middle := make([]float64, 0, length)
	more := make([]float64, 0, length)

	for _, item := range u {
		switch {
		case item < m:
			less = append(less, item)
		case item == m:
			middle = append(middle, item)
		case item > m:
			more = append(more, item)
		}
	}

	less, more = QuickFloat64(less), QuickFloat64(more)

	less = append(less, middle...)
	less = append(less, more...)

	return less
}

func QuickByte(u []byte) []byte {
	length := len(u)

	if length <= 1 {
		sliceCopy := make([]byte, length)
		copy(sliceCopy, u)
		return sliceCopy
	}

	m := u[rand.Intn(length)]

	less := make([]byte, 0, length)
	middle := make([]byte, 0, length)
	more := make([]byte, 0, length)

	for _, item := range u {
		switch {
		case item < m:
			less = append(less, item)
		case item == m:
			middle = append(middle, item)
		case item > m:
			more = append(more, item)
		}
	}

	less, more = QuickByte(less), QuickByte(more)

	less = append(less, middle...)
	less = append(less, more...)

	return less
}

func QuickRune(u []rune) []rune {
	length := len(u)

	if length <= 1 {
		sliceCopy := make([]rune, length)
		copy(sliceCopy, u)
		return sliceCopy
	}

	m := u[rand.Intn(length)]

	less := make([]rune, 0, length)
	middle := make([]rune, 0, length)
	more := make([]rune, 0, length)

	for _, item := range u {
		switch {
		case item < m:
			less = append(less, item)
		case item == m:
			middle = append(middle, item)
		case item > m:
			more = append(more, item)
		}
	}

	less, more = QuickRune(less), QuickRune(more)

	less = append(less, middle...)
	less = append(less, more...)

	return less
}

func QuickUintptr(u []uintptr) []uintptr {
	length := len(u)

	if length <= 1 {
		sliceCopy := make([]uintptr, length)
		copy(sliceCopy, u)
		return sliceCopy
	}

	m := u[rand.Intn(length)]

	less := make([]uintptr, 0, length)
	middle := make([]uintptr, 0, length)
	more := make([]uintptr, 0, length)

	for _, item := range u {
		switch {
		case item < m:
			less = append(less, item)
		case item == m:
			middle = append(middle, item)
		case item > m:
			more = append(more, item)
		}
	}

	less, more = QuickUintptr(less), QuickUintptr(more)

	less = append(less, middle...)
	less = append(less, more...)

	return less
}
